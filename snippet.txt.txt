{
    // Snippet for Forward and Central Difference
    "Numerical Differentiation": {
        "prefix": "numdiff",
        "body": [
            "import numpy as np",
            "import matplotlib.pyplot as plt",
            "",
            "# Forward difference (n+1 formula)",
            "def forward_difference(f, x, h):",
            "    return (f(x + h) - f(x)) / h",
            "",
            "# Three-point central difference formula",
            "def three_point_formula(f, x, h):",
            "    return (f(x + h) - f(x - h)) / (2 * h)",
            "",
            "# True derivative of f(x) = e^x * sin(x)",
            "def true_derivative(x):",
            "    return np.exp(x) * np.sin(x) + np.exp(x) * np.cos(x)",
            "",
            "# Define a more complex function to differentiate: f(x) = e^x * sin(x)",
            "def f(x):",
            "    return np.exp(x) * np.sin(x)",
            "",
            "# Range of x values for plotting",
            "x_values = np.linspace(0.1, 5, 100)",
            "h = 0.01  # Step size for numerical differentiation",
            "",
            "# Compute the true derivatives",
            "true_values = true_derivative(x_values)",
            "",
            "# Compute the forward difference and three-point formula results",
            "forward_values = forward_difference(f, x_values, h)",
            "three_point_values = three_point_formula(f, x_values, h)",
            "",
            "# Compute the errors",
            "forward_error = np.abs(true_values - forward_values)",
            "three_point_error = np.abs(true_values - three_point_values)",
            "",
            "# Plot the numerical derivatives and the true derivative",
            "plt.figure(figsize=(12, 6))",
            "plt.plot(x_values, true_values, label=\"True Derivative\", color='black', linestyle='--')",
            "plt.plot(x_values, forward_values, label=\"Forward Difference\", color='blue')",
            "plt.plot(x_values, three_point_values, label=\"Three-Point Formula\", color='red')",
            "plt.title('Numerical Differentiation: Forward Difference vs Three-Point Formula')",
            "plt.xlabel('x')",
            "plt.ylabel('Derivative')",
            "plt.legend()",
            "plt.grid(True)",
            "plt.show()",
            "",
            "# Plot the errors",
            "plt.figure(figsize=(12, 6))",
            "plt.plot(x_values, forward_error, label=\"Error in Forward Difference\", color='blue', linestyle='--')",
            "plt.plot(x_values, three_point_error, label=\"Error in Three-Point Formula\", color='red', linestyle='--')",
            "plt.title('Error in Numerical Differentiation Methods')",
            "plt.xlabel('x')",
            "plt.ylabel('Error')",
            "plt.legend()",
            "plt.grid(True)",
            "plt.show()"
        ],
        "description": "Numerical differentiation using forward and central difference methods"
    },
    // Snippet for Trapezoidal Rule
    "Trapezoidal Rule": {
        "prefix": "trapezoidal",
        "body": [
            "import numpy as np",
            "import matplotlib.pyplot as plt",
            "",
            "# Trapezoidal Rule Implementation",
            "def trapezoidal_rule(f, a, b, n):",
            "    h = (b - a) / n",
            "    integral = 0.5 * (f(a) + f(b))",
            "    for i in range(1, n):",
            "        integral += f(a + i * h)",
            "    integral *= h",
            "    return integral",
            "",
            "# Define a function to integrate, for example f(x) = x^2",
            "def f(x):",
            "    return x**2",
            "",
            "# Set the bounds and the number of subintervals",
            "a = 0",
            "b = 1",
            "n = 100",
            "",
            "# Compute the integral using the Trapezoidal Rule",
            "result = trapezoidal_rule(f, a, b, n)",
            "print(f\"Approximate integral of f(x) = x^2 from {a} to {b} is: {result}\")",
            "",
            "# Compare with the exact integral",
            "exact_integral = (b**3 - a**3) / 3",
            "print(f\"Exact integral is: {exact_integral}\")",
            "",
            "# Plot the function and the trapezoidal approximation",
            "x_vals = np.linspace(a, b, 1000)",
            "y_vals = f(x_vals)",
            "plt.plot(x_vals, y_vals, label=\"f(x) = x^2\", color='blue')",
            "x_trap = np.linspace(a, b, n+1)",
            "y_trap = f(x_trap)",
            "for i in range(n):",
            "    plt.fill_between(x_trap[i:i+2], y_trap[i:i+2], alpha=0.3, color='orange')",
            "plt.title('Trapezoidal Rule Approximation for f(x) = x^2')",
            "plt.xlabel('x')",
            "plt.ylabel('f(x)')",
            "plt.legend()",
            "plt.grid(True)",
            "plt.show()",
            "",
            "# Calculate error",
            "error = abs(result - exact_integral)",
            "print(f\"Error in Trapezoidal Rule Approximation: {error}\")"
        ],
        "description": "Trapezoidal rule for numerical integration with plot"
    },
    "Gaussian Elimination No Pivot": {
        "prefix": "gaussianelimnopivot",
        "body": [
            "import numpy as np",
            "",
            "def gaussian_elimination_no_pivot(A, b):",
            "    n = len(b)",
            "    # Augmented matrix [A|b]",
            "    Ab = np.hstack([A, b.reshape(-1, 1)])",
            "",
            "    # Forward Elimination",
            "    for i in range(n):",
            "        for j in range(i + 1, n):",
            "            if Ab[j, i] != 0:  # Avoid division by zero",
            "                factor = Ab[j, i] / Ab[i, i]",
            "                Ab[j] = Ab[j] - factor * Ab[i]",
            "",
            "    # Back Substitution",
            "    x = np.zeros(n)",
            "    for i in range(n - 1, -1, -1):",
            "        x[i] = (Ab[i, -1] - np.dot(Ab[i, i + 1:n], x[i + 1:])) / Ab[i, i]",
            "",
            "    return x",
            "",
            "# Example system of equations",
            "A = np.array([[3, 1, 2], [1, 2, 3], [2, 1, 3]], dtype=float)",
            "b = np.array([9, 8, 7], dtype=float)",
            "",
            "# Solve the system using Gaussian elimination (no pivoting)",
            "x = gaussian_elimination_no_pivot(A, b)",
            "print(\"Solution x:\", x)"
        ],
        "description": "Gaussian elimination without pivoting for solving linear systems"
    },
    // Snippet for Euler's Method
    "Euler's Method": {
        "prefix": "euler",
        "body": [
            "import numpy as np",
            "import matplotlib.pyplot as plt",
            "",
            "def euler_method(f, x0, y0, x_end, h):",
            "    x_values = [x0]",
            "    y_values = [y0]",
            "    x = x0",
            "    y = y0",
            "    while x < x_end:",
            "        y = y + h * f(x, y)",
            "        x = x + h",
            "        x_values.append(x)",
            "        y_values.append(y)",
            "    return np.array(x_values), np.array(y_values)",
            "",
            "def example_function(x, y):",
            "    return x - y",
            "",
            "def exact_solution(x):",
            "    return x - 1 + 2 * np.exp(-x)",
            "",
            "x0 = 0",
            "y0 = 1",
            "x_end = 2",
            "h = 0.1",
            "",
            "x_vals, y_vals = euler_method(example_function, x0, y0, x_end, h)",
            "exact_y_vals = exact_solution(x_vals)",
            "",
            "print(\"x         Euler y        Exact y        Error\")",
            "print(\"-\" * 45)",
            "for x, y_euler, y_exact in zip(x_vals, y_vals, exact_y_vals):",
            "    error = abs(y_exact - y_euler)",
            "    print(f\"{x:.2f}      {y_euler:.7f}      {y_exact:.7f}      {error:.7f}\")",
            "",
            "plt.plot(x_vals, y_vals, label=\"Euler's Method Solution\", marker='o')",
            "plt.plot(x_vals, exact_y_vals, label=\"Exact Solution\", linestyle='--')",
            "plt.xlabel(\"x\")",
            "plt.ylabel(\"y\")",
            "plt.legend()",
            "plt.grid()",
            "plt.show()"
        ],
        "description": "Euler's method for solving ODEs with plot"
    },
    // Snippet for Runge-Kutta 4th Order
    "Runge-Kutta 4th Order": {
        "prefix": "rk4",
        "body": [
            "import numpy as np",
            "import matplotlib.pyplot as plt",
            "",
            "def runge_kutta_4th_order(f, x0, y0, x_end, h):",
            "    x_values = [x0]",
            "    y_values = [y0]",
            "    x = x0",
            "    y = y0",
            "    while x < x_end:",
            "        k1 = f(x, y)",
            "        k2 = f(x + h / 2, y + h * k1 / 2)",
            "        k3 = f(x + h / 2, y + h * k2 / 2)",
            "        k4 = f(x + h, y + h * k3)",
            "        y = y + (h / 6) * (k1 + 2 * k2 + 2 * k3 + k4)",
            "        x = x + h",
            "        x_values.append(x)",
            "        y_values.append(y)",
            "    return np.array(x_values), np.array(y_values)",
            "",
            "def example_function(x, y):",
            "    return x - y",
            "",
            "def exact_solution(x):",
            "    return x - 1 + 2 * np.exp(-x)",
            "",
            "x0 = 0",
            "y0 = 1",
            "x_end = 2",
            "h = 0.1",
            "",
            "x_vals, y_vals = runge_kutta_4th_order(example_function, x0, y0, x_end, h)",
            "exact_y_vals = exact_solution(x_vals)",
            "",
            "print(\"x         RK4 y          Exact y        Error\")",
            "print(\"-\" * 45)",
            "for x, y_rk4, y_exact in zip(x_vals, y_vals, exact_y_vals):",
            "    error = abs(y_exact - y_rk4)",
            "    print(f\"{x:.2f}      {y_rk4:.7f}      {y_exact:.7f}      {error:.7f}\")",
            "",
            "plt.plot(x_vals, y_vals, label=\"Runge-Kutta 4th Order\", marker='o')",
            "plt.plot(x_vals, exact_y_vals, label=\"Exact Solution\", linestyle='--')",
            "plt.xlabel(\"x\")",
            "plt.ylabel(\"y\")",
            "plt.legend()",
            "plt.grid()",
            "plt.title(\"Runge-Kutta 4th Order vs Exact Solution\")",
            "plt.show()"
        ],
        "description": "Runge-Kutta 4th order method for solving ODEs with plot"
    },
    // Snippet for Gaussian Elimination
    "Gaussian Elimination": {
        "prefix": "gaussianelim",
        "body": [
            "import numpy as np",
            "",
            "def gaussian_elimination(A, b):",
            "    n = len(b)",
            "    Ab = np.hstack([A, b.reshape(-1, 1)])",
            "    for i in range(n):",
            "        pivot = Ab[i, i]",
            "        if pivot == 0:",
            "            raise ValueError(\"Matrix is singular, cannot proceed with Gaussian elimination.\")",
            "        Ab[i] = Ab[i] / pivot",
            "        for j in range(i + 1, n):",
            "            scale = Ab[j, i]",
            "            Ab[j] = Ab[j] - scale * Ab[i]",
            "    x = np.zeros(n)",
            "    for i in range(n - 1, -1, -1):",
            "        x[i] = Ab[i, -1] - np.dot(Ab[i, i + 1:n], x[i + 1:])",
            "    return x",
            "",
            "# Define the matrix A and vector b",
            "A = np.array([[3, 1], [1, 2]], dtype=float)",
            "b = np.array([9, 8], dtype=float)",
            "",
            "# Solve the system using Gaussian Elimination",
            "x = gaussian_elimination(A, b)",
            "print(\"Solution x:\", x)"
        ],
        "description": "Gaussian elimination for solving linear systems"
    },
    // Snippet for LU Decomposition
    "LU Decomposition": {
        "prefix": "ludecomp",
        "body": [
            "import numpy as np",
            "",
            "def lu_decomposition(A):",
            "    n = A.shape[0]",
            "    L = np.zeros_like(A)",
            "    U = np.zeros_like(A)",
            "    for i in range(n):",
            "        for j in range(i, n):",
            "            U[i, j] = A[i, j] - np.dot(L[i, :i], U[:i, j])",
            "        for j in range(i, n):",
            "            if i == j:",
            "                L[i, i] = 1",
            "            else:",
            "                L[j, i] = (A[j, i] - np.dot(L[j, :i], U[:i, i])) / U[i, i]",
            "    return L, U",
            "",
            "def forward_substitution(L, b):",
            "    n = len(b)",
            "    y = np.zeros_like(b, dtype=float)",
            "    for i in range(n):",
            "        y[i] = b[i] - np.dot(L[i, :i], y[:i])",
            "    return y",
            "",
            "def backward_substitution(U, y):",
            "    n = len(y)",
            "    x = np.zeros_like(y, dtype=float)",
            "    for i in range(n-1, -1, -1):",
            "        x[i] = (y[i] - np.dot(U[i, i+1:], x[i+1:])) / U[i, i]",
            "    return x",
            "",
            "def solve_system(A, b):",
            "    L, U = lu_decomposition(A)",
            "    y = forward_substitution(L, b)",
            "    x = backward_substitution(U, y)",
            "    return x",
            "",
            "# Example Usage",
            "A = np.array([[4, 3], [6, 3]], dtype=float)",
            "b = np.array([10, 12], dtype=float)",
            "",
            "x = solve_system(A, b)",
            "print(\"Solution vector x:\")",
            "print(x)"
        ],
        "description": "LU decomposition for solving linear systems"
    },
    // Snippet for Jacobi Method
    "Jacobi Method": {
        "prefix": "jacobi",
        "body": [
            "import numpy as np",
            "",
            "def jacobi(A, b, x0=None, tol=1e-10, max_iter=1000):",
            "    n = len(b)",
            "    if x0 is None:",
            "        x0 = np.zeros(n)",
            "    x = np.copy(x0)",
            "    for k in range(max_iter):",
            "        x_new = np.zeros_like(x)",
            "        for i in range(n):",
            "            summation = 0",
            "            for j in range(n):",
            "                if i != j:",
            "                    summation += A[i, j] * x[j]",
            "            x_new[i] = (b[i] - summation) / A[i, i]",
            "        max_diff = 0",
            "        for i in range(n):",
            "            max_diff = max(max_diff, abs(x_new[i] - x[i]))",
            "        if max_diff < tol:",
            "            print(f\"Converged in {k + 1} iterations.\")",
            "            return x_new",
            "        x = x_new",
            "    print(\"Maximum iterations reached.\")",
            "    return x",
            "",
            "# Example usage:",
            "A = np.array([[4, -1, 0, 0],",
            "              [-1, 4, -1, 0],",
            "              [0, -1, 4, -1],",
            "              [0, 0, -1, 3]], dtype=float)",
            "",
            "b = np.array([15, 10, 10, 10], dtype=float)",
            "",
            "solution = jacobi(A, b)",
            "print(\"Solution:\", solution)"
        ],
        "description": "Jacobi iterative method for solving linear systems"
    },
    // Snippet for Gauss-Seidel Method
    "Gauss-Seidel Method": {
        "prefix": "gaussseidel",
        "body": [
            "import numpy as np",
            "",
            "def gauss_seidel(A, b, x0=None, tol=1e-10, max_iter=1000):",
            "    n = len(b)",
            "    if x0 is None:",
            "        x0 = np.zeros(n)",
            "    x = np.copy(x0)",
            "    for k in range(max_iter):",
            "        x_old = np.copy(x)",
            "        for i in range(n):",
            "            summation = 0",
            "            for j in range(n):",
            "                if i != j:",
            "                    summation += A[i, j] * x[j] if j < i else A[i, j] * x_old[j]",
            "            x[i] = (b[i] - summation) / A[i, i]",
            "        max_diff = 0",
            "        for i in range(n):",
            "            max_diff = max(max_diff, abs(x[i] - x_old[i]))",
            "        if max_diff < tol:",
            "            print(f\"Converged in {k + 1} iterations.\")",
            "            return x",
            "    print(\"Maximum iterations reached.\")",
            "    return x",
            "",
            "# Example usage:",
            "A = np.array([[4, -1, 0, 0],",
            "              [-1, 4, -1, 0],",
            "              [0, -1, 4, -1],",
            "              [0, 0, -1, 3]], dtype=float)",
            "",
            "b = np.array([15, 10, 10, 10], dtype=float)",
            "",
            "solution = gauss_seidel(A, b)",
            "print(\"Solution:\", solution)"
        ],
        "description": "Gauss-Seidel iterative method for solving linear systems"
    }
}